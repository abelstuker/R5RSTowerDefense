(load "constants-and-auxfunctions.rkt")

(define (make-projectile level tower position movement type)
  (let ((distance-from-tower 0)
        (delay-counter 0)
        (check-collision? (if (or (= type 0) (= type 1)) #t #f))
        (returning-to-tower? #f))

    ; Update function of the projectile
    (define (update! ms monsters screen)

      (cond ((or (= type 0) (= type 1))
             (if (>= distance-from-tower (tower-config-range type))
                 (delete-projectile!)
                 (move-projectile! movement ms screen)))
            ((= type 2)
             (if (<= distance-from-tower 1)
                 (move-projectile! movement ms screen)
                 (delete-projectile!)))
            ((= type 3)
             (cond ((or (and (not returning-to-tower?)
                             (< distance-from-tower 1))
                        (and returning-to-tower?
                             (>= distance-from-tower 0)))  ; when the net is moving from or back to the tower
                    (move-projectile! movement ms screen))
                   (returning-to-tower? ; when the net is fully returned to the tower
                    (delete-projectile!))
                   ((= delay-counter 0) ; when the net has arrived at the pathcell
                    (set-delayed-path!)
                    (update-delay-counter! ms))
                   ((< delay-counter slow-down-time) ; when the net is staying at the pathcell
                    (update-delay-counter! ms))
                   (else ; when the net has stayed at the pathcell for long enough
                    (return-to-tower!))))
            (else (display ("ERROR -- invalid tower type on update function")))))

    (define (delete-projectile!)
      ((level 'remove-projectile!) dispatch))
    
    (define (move-projectile! movement ms screen)
      (set! distance-from-tower ((if returning-to-tower? - +) distance-from-tower ((position 'move!) movement ms))) ; add the elapsed distance in the current update time interval to the total distance-from-tower
      ((screen 'draw-projectile!) dispatch (tower-config-projectile-scale? type))) ; ... and draw the projectile again

    (define (update-delay-counter! ms)
      (set! delay-counter (+ delay-counter ms)))

    ; Procedure called when a 'net' has arrived (i.e. distance-from-tower >= 1) and the underlying pathcell should be informed to slow down its monsters.
    (define (set-delayed-path!)
      ((tower 'get-nearest-pathcell) 'set-delayed!))
    ; Procedure called when a 'net' disappears and therefore the underlying pathcell should stop slowing down its monsters.
    (define (unset-delayed-path!)
      ((tower 'get-nearest-pathcell) 'unset-delayed!))

    (define (return-to-tower!)
      (unset-delayed-path!) 
      ((movement 'mirror-movement!))
      (set! returning-to-tower? #t))
      
    ; The collide! executes the collision by hurting the monster and removing the projectile, and returns whether the projectile has to remain drawed.
    (define (collide! monster)
      ((monster 'hurt!) 1);(tower-config-projectile-damage type))
      ; TODO check for slow down or move back
      ((level 'remove-projectile!) dispatch))

    (define (get-image-file)
      (tower-config-projectile-image type))
    (define (get-image-mask-file)
      (string-append (tower-config-projectile-image type) "-mask"))

    (define (dispatch msg)
      (cond ((eq? msg 'update!) update!)
            ((eq? msg 'get-position) position)
            ((eq? msg 'get-image-file) get-image-file)
            ((eq? msg 'get-image-mask-file) get-image-mask-file)
            ((eq? msg 'collide!) collide!)
            ((eq? msg 'get-scale) distance-from-tower)
            ((eq? msg 'check-collision?) check-collision?)
            (else (display "ERROR - make-projectile dispatch message not understood: ") (display msg))))
    dispatch))