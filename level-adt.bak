(#%require (only racket/base random))
(load "constants-and-auxfunctions.rkt")
(load "screen-adt.rkt")
(load "position-adt.rkt")
(load "tower-adt.rkt")
(load "monster-adt.rkt")
(load "path-adt.rkt")
(load "object-list-adt.rkt")
(load "tower-picker-menu-adt.rkt")


(define (make-level screen level-number)
  (let ((path #f) 
        (towers (make-object-list)) ; headed list with the amount of towers as header value
        (monsters (make-object-list)) ; headed list with the amount of monsters as header value
        (projectiles (make-object-list)) ; headed list with the amount of projectiles as header value
        (tower-picker-menu (make-tower-picker-menu 0))
        (rest-waves #f))

    ; Mouse-click procedure
    (define (mouseclick key status x y)
      (let* ((x-pos (quotient x cell-width))
             (y-pos (quotient y cell-height))
             (position (make-position x-pos y-pos)))
        (if (and (eq? key 'left)
                 (eq? status 'pressed))
            (cond (((position 'in-gamefield?)) (add-tower! position))
                  (((position 'in-sidebar?))
                   (display "in sidebar") (newline)
                   (let ((item ((tower-picker-menu 'get-tower-item-from-position) position)))
                     (display "item: ") (display item) (newline)
                     (if item
                         ((screen 'draw-tower-item-selector) item))))))))
                          

    ; Key-press procedure
    (define (key-press status key)
      (display "status: ") (display status) (display "key: ") (display key) (newline)
      (if (and (eq? status 'pressed)
               (eq? key #\space)
               (= 0 (monsters 'get-count)))
          (begin (display "key to startwave") (newline) (start-wave!))) ; in phase 2: start new level using Game ADT when rest-waves is null
      (if (and (eq? status 'pressed)
               (eq? key #\r)
               (= 0 (monsters 'get-count)))
          (begin (display "key to reset") (newline) (restart!))))
    

    ;    ; remove object from list
    ;    (define (remove-object! object list)
    ;      (define (hulp lst previous)
    ;        (cond ((null? lst) #f)
    ;              ((equal? (car lst) object)
    ;               (display "removing object . . .") (newline)
    ;               (if (null? (cdr lst))
    ;                   (set-cdr! previous '())
    ;                   (set-cdr! previous (cdr lst)))
    ;               (set-car! list (- (car list) 1)))
    ;              (else (hulp (cdr lst) (cdr previous)))))
    ;      (hulp (cdr list) list))
    ;
    ;    ; Procedure adds an object to list
    ;    (define (add-object! object list)
    ;      (set-car! list (+ (car list) 1))
    ;      (set-cdr! list (cons object (cdr list))))
    
    ; Procedure updates all the game objects
    (define (update! ms)
      (if (not (= 0 (monsters 'get-count)))
          ((screen 'write-text-under!) (string-append "Monsters to kill: " (number->string (monsters 'get-count))) (string-append "Towers on the field: " (number->string (towers 'get-count))))
          ((screen 'write-text-under!) "Press the spacebar to start another wave, press r to restart the game."))
     
      ; updating the monsters
      (for-each (lambda (el) ((el 'update!) ms path screen))
                (monsters 'get-objects))
      ; updating the towers
      (for-each (lambda (el) ((el 'update!) ms (monsters 'get-objects)))
                (towers 'get-objects))
      ; updating the projectiles
      (for-each (lambda (el) ((el 'update!) ms (monsters 'get-objects) dispatch screen))
                (projectiles 'get-objects)))
      

    ; Procedures to add and remove MONSTERS:
    (define (add-monster!)
      (let* ((first-pathcell ((path 'get-first-pathcell)))
             (new-monster (make-monster first-pathcell dispatch 1))
             (monster-position (new-monster 'get-position)))
        ((monsters 'add-object!) new-monster)
        new-monster))

    (define (remove-monster! monster)
      ((screen 'clear-monster!) monster)
      ((monsters 'remove-object!) monster)
      (display "remove-monster! done (level)") (newline))

    ; Procedures to add TOWERS (removing towers will be introduced in phase 2):
    (define (add-tower! position)
      (if (and (not ((position 'object-in-position?) (path 'get-path)))
               (not ((position 'object-in-position?) (towers 'get-objects)))
               (< (position 'get-grid-x) horizontal-cells-amount)
               (< (position 'get-grid-y) vertical-cells-amount))
          (let ((tower (make-tower position dispatch 1)))
            (display "adding a tower") (newline)
            ((towers 'add-object!) tower)
            ((screen 'draw-tower!) tower))
          (begin (display "adding a tower is not possible at this location") (newline))))

    ; Procedures to add and remove PROJECTILES:
    (define (add-projectile! projectile)
      ((projectiles 'add-object!) projectile))

    (define (remove-projectile! projectile)
      ((screen 'clear-projectile!) projectile)
      ((projectiles 'remove-object!) projectile)
      (display "remove-projectile! done (level)") (newline))

    ; Procedure makes a number of monsters spawn:
    (define (monster-spawner! count)
      (if (> count 0)
          (begin
            ((screen 'draw-monster!) (add-monster!))
            (monster-spawner! (- count 1)))))

    ; Start procedure:
    (define (start!)
      ((screen 'draw-tower-picker!) tower-picker-menu)
      ((screen 'draw-tower-item-selector) (vector-ref (tower-picker-menu 'get-picker-items) 0))
      (set! rest-waves wave-instructions)
      (set! path (make-path screen path-instructions))
      ((screen 'set-update-procedure!) update!)
      ((screen 'set-mouseclick-procedure!) mouseclick)
      ((screen 'set-key-procedure!) key-press)
      (start-wave!))

    ; Procedure starts a wave:
    (define (start-wave!)
      (display "start wave")
      (cond ((number? rest-waves) 
             (monster-spawner! rest-waves))
            ((not (null? rest-waves))
             (monster-spawner! (car rest-waves))
             (set! rest-waves (cdr rest-waves)))))

    ; Procedure resets the current level:
    (define (restart!)
      (set! towers (make-object-list))
      ((screen 'clear-all-towers!))
      (set! monsters (make-object-list))
      (set! projectiles (make-object-list))
      ((screen 'clear-all-projectiles!))
      (start!))
             

    (define path-instructions
      (cond ((= level-number 1) '(3 R U U R R R D D D R R R R U U R R))
            (else (display "No path instructions defined for level: ") (dispaly level-number) '())))

    (define wave-instructions
      (cond ((= level-number 1) 20)
            (else (display "No wave instructions defined for level: ") (display level-number) '())))

    (define (dispatch msg)
      (cond
        ((eq? msg 'start!) start!)
        ((eq? msg 'remove-monster!) remove-monster!)
        ((eq? msg 'add-projectile!) add-projectile!)
        ((eq? msg 'remove-projectile!) remove-projectile!)))
    dispatch))